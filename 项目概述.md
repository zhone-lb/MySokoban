# 项目概览
## 基础框架
### 基础组件
用抽象类，继承，接口等分级实现
#### 页面
窗口事件重写（关闭，放大缩小，最小化等）

窗口界面重绘

子类：登录界面，游戏界面
#### 可动单位
实现异步动画（注意处理多线程异常）

子类：玩家，箱子，敌怪，道具等
#### 功能按钮
重绘，重写聚焦逻辑

#### 键盘适配器
实现键盘事件响应逻辑

对于特殊关卡可以重写

注意锁定键盘焦点，以绑定键盘事件

注意：抽象类可以用虚拟内部类实例化
#### 存档
文件IO（注意异常）

自动存档，意外关闭保护

事件回溯

不同用户的信息存储
#### UI与数据线程分离
UI操作必须在EDT（事件分发线程）上执行，使用SwingUtilities.invokeLater()实现强制在EDT上进行

对于数据处理和计时器操作需要新开线程，可以用SwingWorker.doitBackground()，或者new Runnable实现
#### 更好的动画效果
### 算法实现
#### 非法局面判定
sokoban文件中定义的`soft fail`，即无法胜利
#### 随机地图生成
#### 路径规划
提示功能的实现
## 拓展内容
### 敌怪AI
### 伪3D
慎重考虑，因为会非常耗时

（如果只是平面地图3D化还好，搞三维地图就有点痛苦了）
### 额外关卡
目前能想到的拓展内容都只能在额外关卡上实现

想法：俄罗斯方块，祖玛，boss战，多角色（多人模式/切换），2048，自定义关卡，重力场，随机模式
### 联网功能
（真的用得上吗）
### 光标美化
## 亟待解决的问题
基础关卡是用系统绘制还是用外部美术资源？

> 如果用外部美术资源的话，是统一主题还是随意组合

组件通信是用事件通信还是直接调用方法？
# 补充
## 事件（Event）
许多UI操作都会产生事件，如拉伸窗口，关闭窗口，滑动滚动条，按键按下，鼠标点击等

这些事件会遵循以下流程进行传递：

> 1、捕获阶段（Capture Phase）：事件从顶层容器（如JFrame）向下传播到事件源组件。
> 2、冒泡阶段（Bubbling Phase）：事件从事件源组件向上传播回顶层容器。

事件源即产生事件的组件（如JButton被按下，JButton就是源）

可以在事件源组件添加监听器（如ActionListener）和适配器（如WindowAdpter），它们在接受事件时启动，未接受到事件时冻结

也可以在父亲组件内添加监听器和适配器，但是它们只在冒泡阶段接受来自儿子组件的事件，并且只有部分事件会有冒泡阶段

>可以用consume()拦截事件传播
存在方法在捕获阶段就接收事件
存在方法可以手动传递不能冒泡的事件
EventBus可以随意指定事件的接受和发送

## 焦点（Focus）

键盘焦点（Keyboard Focus）：指能够接收键盘输入的组件。例如，在文本框中输入文字或通过键盘操作（如方向键）选择列表项。（就是键盘光标在哪个组件上闪）

鼠标焦点（Mouse Focus）：指鼠标光标所在的组件，尽管这不总是影响程序的行为，但有时用于上下文菜单或鼠标事件。

聚焦（焦点回到该组件上）和失焦也是事件

## 事件分发线程（Event Dispatch Thread）
UI操作必须在EDT（事件分发线程）上执行，否则程序会崩溃或造成不可预测的错误

使用SwingUtilities.invokeLater()实现强制在EDT上进行，SwingUtilities.isEventDispatchThread()检查当前线程是否是EDT

但是EDT只是个单线程，无法满足一些动画需求，所以需要多线程

注意：不能在EDT上执行耗时操作（就像枚举1~1e9之类），否则UI界面会卡在那儿，所以只在EDT上执行简短的UI操作

对于动画则可以新开一个线程，加个计时器反复刷新组件，实现方法：

> SwingWorker.doInBackground()把任务丢到后台，publish(),done()可以把结果发送到前台
> 自己实现Runnable或者Thread，即新开一个线程

## 序列化（Serializable）
所有待存储类都要`implements Serializeble`

注意非序列化属性（如监听器、父容器引用等）不会被保存，因此在反序列化后需要重新设置。